rowDuplicateAt <- function(row, column, sep) {
  # Duplicates a row for every unique element in generated by splitting the
  # element in "column" by "sep"
  row <- as_tibble_row(row)
  splits <- row[[column]] %>%
    str_split_1(., sep) %>%
    unique()
  return(
    uncount(row, length(splits)) %>% mutate("{column}" := splits)
  )
}

tibbleDuplicateAt <- function(tibble, col, separator) {
  # Perform "rowDuplicateAt" for to every applicable row in the tibble
  numeric_cols <- tibble %>%
    dplyr::select(where(is.numeric)) %>%
    colnames()
  applicable <- tibble %>% filter(grepl(separator, !!as.symbol(col)))
  if (nrow(applicable) != 0) {
    applicable <- applicable %>%
      apply(., 1, \(x) {
        rowDuplicateAt(x, column = col, sep = separator)
      }) %>%
      bind_rows()
  }
  if (length(numeric_cols) > 0) {
    applicable <- applicable %>% mutate_at(., numeric_cols, as.numeric)
  }
  not_applicable <- tibble %>% filter(!grepl(separator, !!as.symbol(col)))
  return(bind_rows(applicable, not_applicable))
}

cleanPeptide <- function(pep) {
  # Leave only residue characters in a peptide sequence
  if (grepl("\\]|[a-z0-9.]|-", pep)) {
    pep <- str_to_upper(pep) %>%
      str_extract_all("[A-Z]") %>%
      unlist() %>%
      paste0(collapse = "")
  }
  return(pep)
}

mostAbund <- function(grouped_df) {
  p <- pick(base_peptide)$base_peptide
  up <- unique(p)
  tab <- tabulate(match(p, up))
  abund <- up[tab == max(tab)]
  current <- grouped_df[cur_group_rows(),]
  choices <- filter(current, base_peptide %in% abund)
  if (nrow(choices) > 1) {
    return(sample_n(choices, 1))
  }
  return(choices)
}
