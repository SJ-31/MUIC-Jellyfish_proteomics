flattenBy <- function(vector, sep) {
  lapply(vector, \(x) str_split(x, sep)) %>% unlist()
}

rowDuplicateAt <- function(row, column, sep) {
  # Duplicates a row for every unique element in generated by splitting the
  # element in "column" by "sep"
  row <- as_tibble_row(row)
  splits <- row[[column]] %>%
    str_split_1(., sep) %>%
    unique()
  return(
    uncount(row, length(splits)) %>% mutate("{column}" := splits)
  )
}

tibbleDuplicateAt <- function(tibble, col, separator) {
  # Perform "rowDuplicateAt" for to every applicable row in the tibble
  numeric_cols <- tibble %>%
    dplyr::select(where(is.numeric)) %>%
    colnames()
  logical_cols <- tibble %>%
    dplyr::select(where(is.logical)) %>%
    colnames()
  applicable <- tibble %>% filter(grepl(separator, !!as.symbol(col)))
  if (nrow(applicable) != 0) {
    applicable <- applicable %>%
      apply(., 1, \(x) {
        rowDuplicateAt(x, column = col, sep = separator)
      }) %>%
      bind_rows()
  }
  if (length(numeric_cols) > 0) {
    applicable <- applicable %>% mutate_at(., numeric_cols, as.numeric)
  }
  if (length(logical_cols) > 0) {
    applicable <- applicable %>% mutate_at(., logical_cols, as.logical)
  }
  not_applicable <- tibble %>% filter(!grepl(separator, !!as.symbol(col)))
  return(bind_rows(applicable, not_applicable))
}

cleanPeptide <- function(pep) {
  # Leave only residue characters in a peptide sequence
  if (grepl("\\]|[a-z0-9.]|-", pep)) {
    pep <- str_to_upper(pep) %>%
      str_extract_all("[A-Z]") %>%
      unlist() %>%
      paste0(collapse = "")
  }
  return(pep)
}

mostAbund <- function(grouped_df) {
  p <- pick(base_peptide)$base_peptide
  up <- unique(p)
  tab <- tabulate(match(p, up))
  abund <- up[tab == max(tab)]
  current <- grouped_df[cur_group_rows(), ]
  choices <- filter(current, base_peptide %in% abund)
  if (nrow(choices) > 1) {
    return(sample_n(choices, 1))
  }
  return(choices)
}

ggplotNumericDist <- function(lst, method = "hist", ...) {
  if (is.null(names(lst))) {
    names(lst) <- LETTERS[seq_along(lst)]
  }
  tb <- purrr::lmap(lst, \(x) tibble(freq = x[[1]], id = names(x))) %>%
    bind_rows()
  if (method == "boxplot") {
    plot <- tb %>% ggplot(aes(x = id, y = freq, color = id)) +
      geom_boxplot(...)
  } else if (method == "hist") {
    plot <- tb %>% ggplot(aes(x = freq, color = id, fill = id)) +
      geom_histogram(...)
  } else if (method == "ridgeline") {
    plot <- tb %>% ggplot(aes(y = id, color = id, fill = id, x = freq)) +
      ggridges::geom_density_ridges(...)
  } else if (method == "freq_poly") {
    plot <- tb %>% ggplot(aes(x = freq, color = id)) +
      geom_freqpoly(...)
  } else {
    warning("No supported method given")
  }
  return(plot)
}

addPrefix <- function(vector, prefix) {
  map_chr(vector, \(x) glue("{prefix}{x}"))
}

#' Given a list A and B (can be named or not) containing the
#' same number of vector elements, return a list C where
#' the corresponding vectors of A and B have been joined
#' @param A list of vectors
#' @param B list of vectors (same number as A)
mergeLists <- function(A, B) {
  if ((!is.null(names(A)) && !is.null(names(B))) && any(names(A) != names(B))) {
    stop("If lists are named, they must have the same elements!")
  } else if (length(A) != length(B)) {
    stop("Lists don't have the same lengths")
  }
  map2(A, B, \(x, y) c(x, y))
}

#' Return a function that for a given string,
#'  substitutes a element in vector `old` with
#' its corresponding element in `new`.
#' `fn` is an additional function to apply regardless of matching
substituteAll <- function(old, new, fn = NULL) {
  fun <- function(x) {
    for (i in seq_along(old)) {
      if (str_detect(x, old[i])) {
        return(gsub(old[i], new[i], x))
      }
    }
    if (!is.null(fn)) {
      return(fn(x))
    }
    return(x)
  }
  fun
}

#' Verify a function's arguments
#' If `arg` fails the predicate, then stop is called, and the name of the
#' function is printed
#' @param arg Function argument
#' @param predicate Predicate function, such as one that checks if `arg`
#' is of a specific class
assertArg <- function(arg, predicate) {
  if (!predicate(arg)) {
    callstack <- sys.calls()
    top_level <- deparse(callstack[[1]])
    fn_start <- str_locate(top_level, "\\(")[, 2] - 1
    caller <- str_sub(top_level, start = 1L, end = fn_start)
    last <- deparse(callstack[[length(callstack)]])
    failed_arg <- str_extract(last, "assertArg\\((.*),", group = 1)
    message <- glue("wrong argument in `{caller}`")
    message <- glue("{message}\n  Incorrect argument `{failed_arg}`")
    stop(message, call. = FALSE)
  }
}

#' Run pairwise tests against elements in `to_test`, using a
#' pre-determined testing function.
#' Note: does not adjust for multiple testing
testAllPairs <- function(to_test, hypothesisTest) {
  assertArg(to_test, \(x) class(x) == "list" && !is.null(names(x)))
  combos <- combn(names(to_test), 2)
  lapply(seq_len(ncol(combos)), \(x) {
    a <- combos[1, x]
    b <- combos[2, x]
    test <- hypothesisTest(
      to_test[[a]],
      to_test[[b]]
    )
    tibble(comparison = glue("{a} x {b}"), p_value = test$p.value, alternative = test$alternative)
  }) %>% bind_rows()
}

table2Tb <- function(table, id_col) {
  assertArg(table, \(x) class(x) == "table")
  tb <- as_tibble(table, .name_repair = "unique")
  colnames(tb)[1] <- id_col
  tb
}

table2Df <- function(table) {
  assertArg(table, \(x) class(x) == "table")
  convertRow <- function(n) {
    as.list(table[n, ]) %>% as.data.frame()
  }
  purrr::reduce(seq_len(nrow(table)), \(acc, x) {
    bind_rows(acc, convertRow(x))
  }, .init = data.frame()) %>% `rownames<-`(rownames(table))
}



lget <- function(lst, arg, default) {
  find <- lst[[arg]]
  if (is.null(find)) {
    default
  } else {
    find
  }
}

seqkitStat <- function(filename) {
  call <- system2(
    command = "seqkit", args = c("stat", filename, "-T"),
    stdout = TRUE
  ) %>%
    lapply(., \(x) str_split_1(x, "\t"))
  tb <- as_tibble(setNames(as.list(call[[2]]), call[[1]]))
  if (length(call) > 2) {
    tb <- purrr::reduce(call[3:length(call)], \(x, y) {
      row <- as_tibble(setNames(as.list(y), call[[1]]))
      bind_rows(x, row)
    }, .init = tb)
  }
  return(tb)
}
